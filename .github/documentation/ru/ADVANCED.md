# Продвинутое использование WP File System

Эта документация предназначена для разработчиков, которые хотят глубже понять, как работает библиотека WP File System,
и использовать ее расширенные возможности, такие как хуки, защищенный режим и ручное создание экземпляров сервисов.

## Основы файловой системы WordPress и методы доступа

Чтобы понять всю мощь библиотеки WPFS, важно знать, какую проблему она решает на самом низком уровне.
WordPress для обеспечения безопасности и совместимости с различными хостинг-окружениями использует абстракцию для 
доступа к файлам — WP_Filesystem. Эта абстракция может работать в нескольких режимах (методах).


| Метод                                       | Описание                                                                                                                                                                                       | Когда используется                                                                                                                 |
|:--------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------|
| `direct`                                    | Самый простой и быстрый метод. Файловые операции выполняются напрямую с помощью PHP-функций (fopen, fwrite и т.д.) от имени пользователя, от которого запущен веб-сервер (например, www-data). | Используется по умолчанию на правильно настроенных серверах, где у веб-сервера есть права на запись в нужные директории WordPress. |
| `ssh2`                                      | Операции выполняются через безопасное SSH-соединение с сервером, используя предоставленные учетные данные.                                                                                     | Используется на серверах, где у веб-сервера нет прямых прав на запись, но есть доступ по SSH. Требует наличия PHP-расширения ssh2. |
| `ftpext`                                    | Операции выполняются через FTP, используя учетные данные FTP-пользователя, у которого есть права на запись.                                                                                    | Распространенный метод на виртуальных хостингах. Требует наличия PHP-расширения ftp.                                               |
| `ftpsockets`                                | Альтернативная реализация FTP-клиента на чистых сокетах PHP. Используется, если расширение ftp недоступно.                                                                                     | Резервный вариант для FTP, который не требует дополнительных PHP-расширений.                                                       |


### Проблемы и их решение с помощью WPFS

- Проблема прав доступа: Если использовать `direct` на сервере, где у `www-data` нет прав на запись в папку 
`wp-content/uploads`, любая попытка сохранить файл завершится ошибкой.
- Проблема учетных данных: Методы `ssh2` и `ftp*` требуют учетных данных. WordPress обычно запрашивает их у пользователя
через форму в админ-панели. Это делает невозможным выполнение файловых операций в фоновом режиме (например, по CRON)
или через API.

### Как WPFS это решает:

1. Автоматическая инициализация: WPFS автоматически инициализирует WP_Filesystem, избавляя вас от необходимости 
делать это вручную.
2. Использование констант: WPFS полагается на то, что для не интерактивных операций (CRON, WP-CLI) учетные данные 
будут определены в `wp-config.php` в виде констант. Это стандартная практика WordPress.

### Конфигурация в wp-config.php

Вы можете принудительно задать метод доступа и указать учетные данные в файле `wp-config.php`.

```php
// Принудительная установка метода файловой системы
// Возможные значения: 'direct', 'ssh2', 'ftpext', 'ftpsockets'
define('FS_METHOD', 'direct');

// ОСНОВНЫЕ УЧЕТНЫЕ ДАННЫЕ (для FTP, FTPS, SSH2)
define('FTP_HOST', 'your-server.com');
define('FTP_USER', 'username');
define('FTP_PASS', 'password');
define('FTP_PORT', '22'); // Порт 22 для SSH, 21 для FTP

// НАСТРОЙКИ СОЕДИНЕНИЯ
define('FTP_SSL', false); // true для FTPS (только для FTP методов)

// SSH КЛЮЧИ (альтернатива паролю для SSH2)
define('FTP_PUBKEY', '/home/user/.ssh/id_rsa.pub');
define('FTP_PRIKEY', '/home/user/.ssh/id_rsa');

// ПРАВА ДОСТУПА ПО УМОЛЧАНИЮ
define('FS_CHMOD_DIR', 0755);
define('FS_CHMOD_FILE', 0644);
```

## Провайдеры-декораторы: Хуки и Защитник

По умолчанию FSFactory создает базовые экземпляры сервисов, которые просто вызывают соответствующие функции WordPress.
Однако вы можете глобально включить два мощных декоратора: FSHooksProvider и FSGuardiansProvider.

### FSGuardiansProvider (Защитник)

Назначение: Переключает режим обработки ошибок. По умолчанию, в соответствии с WordPress API, большинство методов в
случае неудачи просто возвращают `false`. Это может затруднить отладку. Когда "Защитник" включен, вместо `false` будут 
выбрасываться типизированные исключения.

- `FSPathNotFoundException`: Ресурс (файл или директория) не найден.
- `FSPermissionException`: Ресурс существует, но прав на выполнение операции недостаточно.
- `FSException`: Общая ошибка файловой системы.

### Как использовать:

```php
use Metapraxis\WPFileSystem\Provider\FSGuardiansProvider;
use Metapraxis\WPFileSystem\Facade\WPFS;
use Metapraxis\WPFileSystem\Exceptions\FSPathNotFoundException;

// Включаем режим исключений
FSGuardiansProvider::setStatus(true);

try {
    $content = WPFS::getContents('/path/to/non-existent-file.txt');
} catch (FSPathNotFoundException $e) {
    wp_log_error($e->getMessage());
} finally {
    // Вы можете отключить его, то есть использовать как временный эффект,
    // или не отключать и ввести тем самым глобальное состояние.
    FSGuardiansProvider::setStatus(false);
}
```

### FSHooksProvider (Хуки)

Назначение: Добавляет возможность "подключаться" к файловым операциям с помощью стандартных хуков WordPress 
(`do_action` и `apply_filters`). Это позволяет легко добавлять логирование, мониторинг или изменять поведение 
операций на лету.

Имена всех хуков можно найти в трейтах внутри `src/Hooks/Collection/`.

### Как использовать:

```php
use Metapraxis\WPFileSystem\Provider\FSHooksProvider;
use Metapraxis\WPFileSystem\Facade\WPFS;
use Metapraxis\WPFileSystem\Hooks\Collection\ActionHooks;

// Включаем хуки
FSHooksProvider::setStatus(true);

// Добавляем действие, которое будет срабатывать ПОСЛЕ записи в любой файл
add_action(ActionHooks::$AFTER_PUT_CONTENTS_ACTION, function($result, $file, $contents) {
    if ($result) {
        // Записываем в отдельный лог информацию об успешной записи
        error_log(sprintf('File written successfully: %s, Size: %d bytes', $file, strlen($contents)));
    }
}, 10, 3);

WPFS::putContents(WP_CONTENT_DIR . '/uploads/my-log.txt', 'New log entry.');

// Отключаем хуки
FSHooksProvider::setStatus(false);
```

## Кеширование экземпляров в FSFactory

FSFactory кеширует созданные экземпляры сервисов, чтобы избежать лишних затрат на их создание. Важно понимать, что ключ
кеша зависит не только от имени класса, но и от текущего состояния FSHooksProvider и FSGuardiansProvider.

Это означает, что в рамках одного запроса может существовать до 4-х разных экземпляров одного и того же сервиса, 
например FSBaseReader:

1. Базовый (хуки и защита отключены).
2. Только с хуками.
3. Только с защитой.
4. С хуками и защитой одновременно.

Фабрика сама управляет этим кешем, гарантируя, что вы всегда получите правильный экземпляр в соответствии с 
текущей конфигурацией провайдеров.

## Ручное создание и декорирование экземпляров

Хотя фасад WPFS и фабрика FSFactory покрывают 99% сценариев, вы можете захотеть вручную создать и сконфигурировать
экземпляр сервиса. Это может быть полезно для внедрения зависимостей (Dependency Injection) в ваши классы.

Процесс происходит по принципу "матрешки" (паттерн Декоратор):

1. Создается базовый объект-адаптер.
2. Он "заворачивается" в декоратор хуков (если нужно).
3. Полученный объект "заворачивается" в декоратор защиты (если нужно).

```php
global $wp_filesystem;

// 1. Создаем базовый экземпляр
$baseAction = new \Metapraxis\WPFileSystem\Adapters\FSBaseAction($wp_filesystem);

// 2. Оборачиваем его в декоратор хуков
$hookableAction = new \Metapraxis\WPFileSystem\Hooks\HookableFSAction($baseAction);

// 3. Оборачиваем результат в декоратор защиты
$guardedAction = new \Metapraxis\WPFileSystem\Guarded\GuardedFSBaseAction($hookableAction);


// Теперь $guardedAction - это полнофункциональный сервис, который
// будет и выполнять хуки, и выбрасывать исключения при ошибках.
// Его можно передать в конструктор другого класса.

class MyPluginService
{
    private $filesystem;

    public function __construct(\Metapraxis\WPFileSystem\Contracts\FSBaseAction $filesystem)
    {
        $this->filesystem = $filesystem;
    }

    public function doSomething()
    {
        try {
            $this->filesystem->putContents('/path/to/file.txt', 'data');
        } catch (\Metapraxis\WPFileSystem\Exceptions\FSException $e) {
            // ...
        }
    }
}

$service = new MyPluginService($guardedAction);
$service->doSomething();
```
